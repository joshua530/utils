git add -p <file> => add only a portion of the changes from the file

git branch <new branch name>
git branch -d <branch to delete>
git branch => list all branches(the current one will be highlighted in green and be identified with an asterisk)

[checkout(switch branches or restore working tree files)]
git checkout <branch to change to>
git checkout -b <branch to create and switch to>
git checkout <commit>
  => make HEAD point to <commit>. The working tree will be restored to its state at that <commit>. This state is called "detached HEAD"
     since HEAD is not pointing to the latest commit as it is supposed to. The working tree can then be edited while in the state of
     <commit>.
  => if you intend to keep the changes you will make to this previous state, create a new branch, checkout to the branch, checkout to the
     commit that you intend to make changes to, checkout to the original branch, merge the branch with the changes with the original branch
     eg if we're on Master
     	 git checkout <previous_commit> => make HEAD point to previous commit
     	 git checkout -b tmp => create new branch and change to it(tmp's HEAD will point to <previous_commit>)
     	 [make changes]
     	 git commit -am <commit message> => commit the changes made
     	 git checkout Master => change to previous branch
     	 git merge tmp => integrate changes with branch
git checkout <commit> <file> => revert only <file> to version at <commit>, keep the rest of the working tree the same as version at HEAD

git clean => remove untracked files from the working tree
options:
    x - remove even ignored files(covered in .gitignore rules)
    n - dry run. Don't do anything. Just show what would happen
    d - also remove untracked directories
    X - remove only files ignored by git
    f - remove untracked files if clean.requireForce is not set to true

git commit => open text editor and add commit message from there
git commit[ -m<message>] => commit with message
git commit --amend => open text editor and amend commit message there
git commit --amend -m<new_message> => amend commit message
git commit -am <message> => add and commit all untracked files in the current directory

git config --get <setting> => get the value of <setting>
git config <setting> <value> => set <setting> to <value>

git diff => check difference between 
git diff [--staged <file>]
git diff <local_branch> repo/<remote_branch>
    => check the difference between the local and remote branch. If there is no message, it means
       they are the same

git fetch[ <remote_repository>]
    => download objects from <remote_repository> without integrating them into your repository
       (A safe version of git pull)

git log [ number][ --pretty=format:%<format>]
git log [ number][ --name-only|name-status|stat] => view file names or changes in the individual files
git log -p <file> => view all commits that have affected <file>

git merge
git mergetool - runs the given merge tool to resolve merge any existing merge conflicts(configured using merge.tool setting)
git merge --abort

git pull[ <remote_repository>] => downloads objects and refs from <remote_repository> and integrates them into your local repository
git pull --allow-unrelated-histories <origin> <branch>

[rebase(use another branch as the new base for your work)]
git rebase -i HEAD~<n>
  => makes HEAD point to the <n>th commit behind HEAD(the current commit). the -i option allows one to interactively choose what
     will be done to the commits that come after the <n>th commit behind the current one.
git rebase <branch>
  => appends <current branch>'s commit history to <branch>, making it appear as if all the commits were made in a 
     straight line. It looks for the <common ancestor> commit of <current branch> and <branch>, detaches commits of <current branch> since 
     <common ancestor> from the <current branch>, appends all of <branch>'s commits since <common ancestor> to the <current branch>, then 
     appends all commits of the <current branch> since <common ancestor> to the now altered <current branch>

git remote -v => view url of remote git repository
git remote add origin <url> => add url of remote repo and name the ref origin

git reset[ --soft] <commit id>
git reset[ --soft] HEAD~<n>
  => move head pointer back <n> commits, while placing the work from those commits in the stage(if you omit --soft, 
     the changes in those commits will be discarded and lost forever
git reset --hard => discard local changes to all files, premanently

[git restore only works with files that are already in the repo(tracked files)]
git restore[ --staged] <file> => remove file from staging area(the changes made to it will be kept once removed from staging area)
git restore <file> => discard changes that you made to file

git show <commit id>

git stash => save local changes so that you can re-use them later
git stash show[stash index]
    => shows changes for latest stash if <stash index> is omitted and for only one stash if <stash index> is given
git stash pop => returns latest stash's changes to the working tree and deletes the stash
git stash push[ path] => saves local changes for <path> if path is given and for all files if <path> is omitted
git stash list => lists all stashes
git stash drop <stash index> => deletes stash with given <stash index>
git stash clear => deletes all stashes

git status => status of the current working tree
git status -uno
    => check whether the branch you are tracking is the same in both the local and remote repository
       if there is no message, the local and remote are the same

git switch <branch> => switch to <branch>
git switch -c <branch> => create <branch> and switch to it


[HEAD]
- ref -> a human readable name that references a commit id(it is essentially a pointer to a commit) eg branch names like master,main,dev 
and tags like v0.1 and v0.2. the commit id that ref points to is dynamic so what ref points to can change over time.
- when referring to a branch a ref like 'master' or 'dev' points to the tip(most recent commit id) for that branch(refs are stored in 
.git/refs)
- head -> a ref that points to the tip(most recent commit) of a branch(.git/refs/heads)
- refs can point to other refs which resolve to the commit id of the destination ref
- HEAD - special ref that points to the commit you are currently working on(the currently checked out commit) - .git/HEAD

branches:
- long running -> exist throughout the lifetime of a project eg main, development. Changes are made to them only via merges
- short lived -> created for purposes which are short term eg a bug fix, feature... Once integration with a long term branch is done,
		  these branches are deleted

branching strategies:
- github flow -> one long lived branch(changes are made to it in the form of commits, not merges)
- gitflow -> several long branches and short lived branches. Changes to the long running branches are made via merges, not commits
	  -> once the short running branches have been merges with the long running ones, they are deleted.
	  
[be careful with]
[commands]
- git read-tree
[pushing content to remote repository]
- if you have a new local repository, make all the first changes in it then push them to a clean remote repository to avoid merge 
conflicts due to unrelated histories between the local and remote repository. The conflict will happen when you try to pull changes from
the remote repository into the local repository when you have already made changes in both of the repositories
[extras]
- don't interrupt a push to remote repo in progress(let it fail by itself
  if it is taking too long. May result in discoordination between local
  and remote repository)

How a file is added to the repository
- Working tree/working directory => index/staging area => repository
- Working tree - directory you are currently working on
- index - where commits are prepared(lists all files in the current branch, their sha1 checksums, timestamps and the file name
- repository - hidden .git directory containing all versions of commited files

Merge conflicts
- Whenever there is a merge conflict:
    - open the file in your text editor
    - solve the conflicts
    - run git add <file>
    - run git commit <msg>



